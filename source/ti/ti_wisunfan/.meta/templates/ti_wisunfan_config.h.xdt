%%{
/*
 * Copyright (c) 2019 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== ti_wisunfan_config.h.xdt ========
 */

let mode = args[0];
let inst;

if (typeof mode !== 'undefined' && mode === "wsms") {
    // Get the WSMS module
    inst = system.modules["/ti/ti_wisunfan/wsms/wsms"].$static;
} else {
    // Get the Wi-SUN module
    inst = system.modules["/ti/ti_wisunfan/ti_wisunfan"].$static;
}

// Get network settings script
const networkScript = system.getScript("/ti/ti_wisunfan/network_config/"
+ "ti_wisunfan_network_config");

// Get transmit power settings script
const powerScript = system.getScript("/ti/ti_wisunfan/power_config/"
+ "ti_wisunfan_power_config");

// Get test mode settings script
const testModeScript = system.getScript("/ti/ti_wisunfan/test_config/"
+ "ti_wisunfan_test_config");

// Get security settings script
const securityScript = system.getScript("/ti/ti_wisunfan/security_config/"
+ "ti_wisunfan_security_config");

// Get common functions script
const Common = system.getScript("/ti/ti_wisunfan/ti_wisunfan_common.js");

// Get RF common script
const rfCommon = system.getScript("/ti/ti_wisunfan/rf_config/"
    + "ti_wisunfan_rf_config_common.js");

function keyTable() {
    const isSecureEnabled = inst.secureLevel !== "macSecurityDisabled";
    const psk = isSecureEnabled ? inst.keyTableDefaultKey : _.repeat("F",32);
    const chunks = _.chunk(psk,2);
    return _.map(chunks, (c)=> "0x" + c[0] + c[1] );
}

function getProjectName(project) {
    switch(project) {
        case "borderrouter":
            return "Border Router";
        case "routernode":
            return "Router";
        case "coapnode":
            return "CoAP";
        case "solarborderrouter":
            return "Border Router";
        case "solarcoapnode":
            return "CoAP";
        default:
            throw new Error("Unhanded project type: " + project);
    }
}

let regChannelMask = rfCommon.getChannelMask(inst.region, inst.phyModeID, inst.ChanPlanID);

%%}
/******************************************************************************
 DO NOT EDIT - This file is generated by the SysConfig tool.
 @file ti_wisunfan_config.h

 @brief TI-15.4 Stack configuration parameters for `getProjectName(inst.project)`
 applications

 *****************************************************************************/
#ifndef TI_154STACK_CONFIG_H
#define TI_154STACK_CONFIG_H

/******************************************************************************
 Includes
 *****************************************************************************/
#include "ti_wisunfan_features.h"

#ifdef __cplusplus
extern "C"
{
#endif
%

/*! Setting for PAN ID */
#define CONFIG_PAN_ID                   `Common.toHexString(inst.panID)`

% if (inst.project.includes("routernode") || inst.project.includes("coapnode")) {
#define CONFIG_WISUN_DEVICE_TYPE             MESH_DEVICE_TYPE_WISUN_ROUTER
% }

% if (inst.project.includes("borderrouter")) {
#define CONFIG_WISUN_DEVICE_TYPE             MESH_DEVICE_TYPE_WISUN_BORDER_ROUTER
% }

/*! Setting for channel spacing */
#define CONFIG_CHANNEL_SPACING           `inst.channelSpacing`

/*! Setting for total number of channels */
#define CONFIG_TOTAL_CHANNELS            `inst.totalChannels`

/*! Setting to get channel 0 center frequency in MHz*/
#define CONFIG_CENTER_FREQ              `inst.centerFrequency`

/*! Setting to get phyModeID */
#define CONFIG_PHY_ID                   `inst.phyModeID`

/*! Setting for operating mode selection */
#define CONFIG_OP_MODE_ID                 OPERATING_MODE_`inst.opModeID`

/*! Setting for operating mode selection */
#define CONFIG_OP_MODE_CLASS               `inst.opModeClass`


/*! Setting to get ccaType */
#define CONFIG_CCA_THRESHOLD                 `inst.ccaThreshold`

/* Setting to get customPhy */
#define CONFIG_CUSTOM_PHY               `inst.customPhy`

/* Setting for regulatory domain */
#define CONFIG_REG_DOMAIN               `inst.regDomain`

% let channelMaskHexArr = Common.channelMaskCHexStrArr(inst["unicastChannelMask"]);
/*!
 Channel mask used when CONFIG_FH_ENABLE is true.
 Represents the list of channels on which the device can hop.
 The actual sequence used shall be based on DH1CF function.
 It is represented as a bit string with LSB representing Ch0.
 e.g., 0x01 0x10 represents Ch0 and Ch12 are included.
 */
#define CONFIG_UNICAST_CHANNEL_MASK       { `_.slice(channelMaskHexArr,0,6)`, \
                                          `_.slice(channelMaskHexArr,6,12)`, \
                                          `_.slice(channelMaskHexArr,12)` }

% channelMaskHexArr = Common.channelMaskCHexStrArr(inst["fhAsyncChannels"]);
/*!
 List of channels to target asynchronous frames when CONFIG_FH_ENABLE = true.
 It is represented as a bit string with LSB representing Ch0
 e.g., 0x01 0x10 represents Ch0 and Ch12 are included
 It should cover all channels that could be used by a target device in its
 hopping sequence. Channels marked beyond number of channels supported by
 PHY Config will be excluded by stack. To avoid interference on a channel,
 it should be removed from Async Mask and excluded from the FH channel mask.
 */
#define CONFIG_ASYNC_CHANNEL_MASK         { `_.slice(channelMaskHexArr,0,6)`, \
                                          `_.slice(channelMaskHexArr,6,12)`, \
                                          `_.slice(channelMaskHexArr,12)` }


% if (inst.project.includes("borderrouter")) {
% channelMaskHexArr = Common.channelMaskCHexStrArr(inst["broadcastChannelMask"]);
/*!
 List of channels to target asynchronous frames when CONFIG_FH_ENABLE = true.
 It is represented as a bit string with LSB representing Ch0
 e.g., 0x01 0x10 represents Ch0 and Ch12 are included
 It should cover all channels that could be used by a target device in its
 hopping sequence. Channels marked beyond number of channels supported by
 PHY Config will be excluded by stack. To avoid interference on a channel,
 it should be removed from Async Mask and excluded from the FH channel mask.
 */
#define CONFIG_BROADCAST_CHANNEL_MASK     { `_.slice(channelMaskHexArr,0,6)`, \
                                          `_.slice(channelMaskHexArr,6,12)`, \
                                          `_.slice(channelMaskHexArr,12)` }

% }
% if (inst.project.includes("routernode") || inst.project.includes("coapnode")) {
#define CONFIG_BROADCAST_CHANNEL_MASK   {0}
% }

% channelMaskHexArr = Common.channelMaskCHexStrArr(regChannelMask);
/*!
 Channel mask used when CONFIG_FH_ENABLE is true.
 Represents the list of channels on which the device can hop, as defined by
 the regulatory domain and operating mode. Does not change based on configured
 unicast, broadcast, or async channel masks.
 The actual sequence used shall be based on DH1CF function.
 It is represented as a bit string with LSB representing Ch0.
 e.g., 0x01 0x10 represents Ch0 and Ch12 are included.
 */
#define CONFIG_REGULATION_CHANNEL_MASK    { `_.slice(channelMaskHexArr,0,6)`, \
                                          `_.slice(channelMaskHexArr,6,12)`, \
                                          `_.slice(channelMaskHexArr,12)` }

/* Setting for FH network name attribute */
#define CONFIG_NETNAME               "`inst.fhNetname`"

% if (inst.project.includes("borderrouter")) {
% // FH broadcast configs required to be generated for collector projects only
/*! Setting for FH application broadcast msg generation interval in ms */
#define CONFIG_BROADCAST_INTERVAL           `inst.fhBroadcastInterval`


/*! Setting for FH application broadcast dwell time in ms */
#define CONFIG_BROADCAST_DWELL_TIME         `inst.fhBroadcastDwellTime`

% }

/*! Setting for FH application unicast msg generation interval in ms */
#define CONFIG_UNICAST_DWELL_TIME        `inst.unicastDwellTime`

% const isSub1BandSet = (inst.freqBand === "freqBandSub1");
% const curTxPowerCfg = inst.transmitPower;
/* ! Setting for transmit power in dBm */
#define CONFIG_TRANSMIT_POWER           `curTxPowerCfg`

/*! Setting to enable frequency hopping mode */
#define CONFIG_FH_ENABLE                `inst.mode === "frequencyHopping" || inst.mode === "fixedChannel"`

% if(inst.mode === "fixedChannel") {

/*! If fixed channel is selected, set the settings for a single channel */
#define CONFIG_CHANNEL_FUNCTION             0
% }
% else {
/*! Setting for interval in ms between tracking message intervals */
#define CONFIG_CHANNEL_FUNCTION             2

% }

#define CONFIG_UNICAST_FIXED_CHANNEL_NUM     `_.first(inst.unicastChannelMask)`
% if (inst.project.includes("borderrouter")) {
#define CONFIG_BROADCAST_FIXED_CHANNEL_NUM   `_.first(inst.broadcastChannelMask)`
% }

% if (!powerScript.getPowerConfigHiddenState(inst, "rxOnIdle")) {
/*! Setting to enable RX on when idle. False for sleepy device */
#define CONFIG_RX_ON_IDLE               `inst.rxOnIdle`

% }

% const keyTableArr = keyTable();
/*! Setting for network security key*/
#define CONFIG_KEY_TABLE_DEFAULT_KEY           { `_.slice(keyTableArr,0,8)`, \
                                          `_.slice(keyTableArr,8)` }

% if (inst.powerTestEnable) {
/*! Setting to enable power measurement test mode */
#define POWER_MEAS

% }
% if (!testModeScript.getTestConfigHiddenState(inst, "powerTestProfile")) {
/* Setting for power profile used for power measurement test mode */
#define POWER_TEST_PROFILE              `inst.powerTestProfile`

% }
% if (!testModeScript.getTestConfigHiddenState(inst, "collectorTestRampDataSize")) {
/* Setting for size of test data used for test modes */
#define COLLECTOR_TEST_RAMP_DATA_SIZE   `inst.collectorTestRampDataSize`

% }
% if (!testModeScript.getTestConfigHiddenState(inst, "sensorTestRampDataSize")) {
/* Setting for size of test data used for test modes */
#define SENSOR_TEST_RAMP_DATA_SIZE      `inst.sensorTestRampDataSize`

% }
#ifdef __cplusplus
}
#endif

#endif /* TI_154STACK_CONFIG_H */
